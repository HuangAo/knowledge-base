# 1. Spring

## 1.1 IoC

### 1.1.1 IoC是什么/好处

控制反转，实现对象间的解偶。

spring IoC， 对象的创建交由spring容器来完成。

IoC带来的好处：对象关系便于管理。

### 1.1.2 IoC原理

反射，可以根据类的全限定名在程序运行时创建对象，将类的全限定名配置在xml文件中，在程序运行时通过反射读取该类的全限定名，动态的创建对象。

Ioc容器可以自动的帮我们完成以上一系列操作，我们需要做的就是通过配置文件告诉ioc容器需要创建哪个类以及类和类之间的关系

### 1.1.3 IoC和DI

IoC是一种思想，依赖注入(DI)是这种思想的一种具体实现

依赖注入的两种方式：构造器注入和setter方法注入

### 1.1.4 spring Ioc循环依赖

#### 1.1.4.1 什么是循环依赖

![image-20200914211815131](D:\techniques\27.other_docs\知识梳理\知识梳理.assets\image-20200914211815131.png)

#### 1.1.4.2 spring ioc怎么解决循环依赖

SpringIOC解决循环依赖的思路就是依靠**缓存**，同时还得引出个概念即**早期暴露引用**。

我们知道在IOC容器里bean的初始化的过程分为三个步骤：创建实例、属性注入实例、回调实例实现的接口方法。

解决思路就在这：当我们创建实例与属性注入实例这两个步骤之间的时候，我们引入缓存，将这些已经创建好但是并没有注入属性的实例

放到缓存里，而这些放在缓存里但是没有被注入属性的实例对象，就是解决循环依赖的方法，打个比方：A对象的创建需要引用到B对

象，而B对象的创建也需要A对象，而此时当B对象创建的时候直接从缓存里引用A对象（虽然不是完全体A对象，毕竟没有赋值处理），当

B对象完成创建以后再被A对象引用进去，则A对象也完成了创建。

 这就是SpringIOC解决bean直接循环依赖的思路当然有一个小问题，IOC能够解决的只能是属性之间的循环依赖，如果有bean之间的构

造器相互依赖则就解决不了只能报错了.

## 1.2 AOP

### 1.2.1 AOP是什么

### 1.2.2 AOP使用场景

### 1.2.3 spring aop的实现原理

## 1.3 bean的生命周期

## 1.4 bean的作用域

# 2. Spring MVC

## 2.1 spring mvc 的工作原理/流程

# 3. Spring boot

## 3.1 springboot的作用/好处

## 3.2 springboot 的起步依赖

## 3.3 怎样创建自己的起步依赖

## 3.4 springboot的自动配置

# 4. Spring cloud

## 4.1 spring cloud是什么/作用？

## 4.2 spring cloud的主要组件

## 4.3 Eureka

## 4.4 Ribbon

## 4.5 Feign / openFeign

## 4.6 Hystrix

## 4.7 Zuul

## 4.8 config



# 5. redis

## 5.1 reids是什么？

## 5.2 redis的应用场景

## 5.3 redis基础知识

## 5.4 redis数据结构

## 5.5 redis事务

## 5.6 redis持久化

## 5.7 redis集群

### 5.7.1 主从复制

### 5.7.2 哨兵模式

## 5.8 redis缓存穿透和雪崩





# 6. 消息中间件

## 6.1 消息中间件的作用

## 6.2 消息中间件使用场景

## 6.3 常见消息中间件比较

## 6.4 MQ的优缺点

## 6.5 如何保证消息队列的高可用

## 6.6 如何保证消息不丢失

## 6.7 如何保证消息不被重复消费/消息幂等性

# 7. jvm

## 7.1 jvm运行时内存布局

## 7.2 GC垃圾回收原理

### 7.2.1 如何判断对象是垃圾

### 7.2.2 哪些内存区域需要GC

### 7.2.3 常用GC算法

## 7.3 内存分配与回收策略

## 7.4 垃圾收集器

## 7.5 虚拟机类加载机制

## 7.6 类加载器双亲委派模型

# 8. 数据库

## 8.1 索引

### 8.1.1 索引的定义

### 8.1.2 mysql索引类型

### 8.1.3 索引设计原则

### 8.1.4 聚集索引和非聚集索引

### 8.1.5 索引的使用

## 8.2 mysql存储引擎

### 8.2.1 存储引擎概述

### 8.2.2 各类存储引擎特性

## 8.3 mysql分库分表

## 8.4 mysql和oracle区别

## 8.5 sql优化步骤

### 8.5.1 查看sql执行频率

### 8.5.2 定位低效率执行sql

### 8.5.3 explain分析执行计划

### 8.5.4 show profile分析sql

### 8.5.5 trace分析优化器执行计划

## 8.6 mysql事务

### 8.6.1 事务的基本要素

### 8.6.2 事务的并发问题

### 8.6.3 mysql事务隔离级别（默认隔离级别：可重复读）

# 9. java基础

## 9.1 集合

### 9.1.1 hashmap

## 9.2 多线程

## 9.3 锁

## 9.4 ThreadLocal

# 10. 设计模式

## 10.1 单例模式

## 10.2 代理模式

# 11. docker

## 11.1 docker概述

## 11.2 docker安装

## 11.3 docker命令

## 11.4 docker镜像

## 11.5 容器数据卷

## 11.6 dockerfile

## 11.7 docker网络原理

## 11.8 IDEA整合docker

## 11.9 docker compose

## 11.10 docker swarm

# 12. linux



# 13. CICD

## 13.1 CICD概述

## 13.2 持续集成工具

### 13.3 javaee项目部署方式比较

#### 13.4 jenkins + svn持续集成环境搭建

# 14. 简历相关

## 14.1 自我介绍

## 14.2 介绍一下做过的项目

## 14.3 说说在项目中负责的部分

# 15. 面试复盘

## 15.1 wonder一面

## 15.2 wonder二面

## 15.3 tenfly

## 15.4 地图慧

## 15.5 OK语音

## 16.6 中软国际



# 16. 技术专题

## 16.1 分布式事务

## 16.2 分布式锁